import { ChangeDetectorRef, ElementRef, EventEmitter, NgZone, OnChanges, OnDestroy, OnInit, Renderer2, SimpleChanges } from '@angular/core';
import { Subject } from 'rxjs';
import { GridsterComponentInterface } from './gridster.interface';
import { GridsterCompact } from './gridsterCompact.service';
import { GridsterConfig } from './gridsterConfig.interface';
import { GridsterConfigS } from './gridsterConfigS.interface';
import { GridsterEmptyCell } from './gridsterEmptyCell.service';
import { GridsterItem, GridsterItemComponentInterface } from './gridsterItem.interface';
import { GridsterRenderer } from './gridsterRenderer.service';
import * as i0 from "@angular/core";
export declare class GridsterComponent implements OnInit, OnChanges, OnDestroy, GridsterComponentInterface {
    renderer: Renderer2;
    cdRef: ChangeDetectorRef;
    zone: NgZone;
    options: GridsterConfig;
    movingItem: GridsterItem | null;
    el: HTMLElement;
    $options: GridsterConfigS;
    mobile: boolean;
    curWidth: number;
    curHeight: number;
    grid: GridsterItemComponentInterface[];
    columns: number;
    rows: number;
    curColWidth: number;
    curRowHeight: number;
    gridColumns: never[];
    gridRows: never[];
    windowResize: (() => void) | null;
    dragInProgress: boolean;
    emptyCell: GridsterEmptyCell;
    compact: GridsterCompact;
    gridRenderer: GridsterRenderer;
    previewStyle$: EventEmitter<GridsterItem | null>;
    calculateLayout$: Subject<void>;
    private resize$;
    private destroy$;
    constructor(el: ElementRef, renderer: Renderer2, cdRef: ChangeDetectorRef, zone: NgZone);
    static checkCollisionTwoItemsForSwaping(item: GridsterItem, item2: GridsterItem): boolean;
    checkCollisionTwoItems(item: GridsterItem, item2: GridsterItem): boolean;
    ngOnInit(): void;
    ngOnChanges(changes: SimpleChanges): void;
    private resize;
    setOptions(): void;
    optionsChanged: () => void;
    ngOnDestroy(): void;
    onResize: () => void;
    checkIfToResize(): boolean;
    checkIfMobile(): boolean;
    setGridSize(): void;
    setGridDimensions(): void;
    private calculateLayout;
    updateGrid(): void;
    addItem(itemComponent: GridsterItemComponentInterface): void;
    removeItem(itemComponent: GridsterItemComponentInterface): void;
    checkCollision(item: GridsterItem): GridsterItemComponentInterface | boolean;
    checkGridCollision(item: GridsterItem): boolean;
    findItemWithItem(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemsWithItem(item: GridsterItem): Array<GridsterItemComponentInterface>;
    autoPositionItem(itemComponent: GridsterItemComponentInterface): void;
    getNextPossiblePosition: (newItem: GridsterItem, startingFrom?: {
        y?: number;
        x?: number;
    }) => boolean;
    getFirstPossiblePosition: (item: GridsterItem) => GridsterItem;
    getLastPossiblePosition: (item: GridsterItem) => GridsterItem;
    pixelsToPositionX(x: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    pixelsToPositionY(y: number, roundingMethod: (x: number) => number, noLimit?: boolean): number;
    positionXToPixels(x: number): number;
    positionYToPixels(y: number): number;
    getItemComponent(item: GridsterItem): GridsterItemComponentInterface | undefined;
    checkCollisionForSwaping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    findItemWithItemForSwapping(item: GridsterItem): GridsterItemComponentInterface | boolean;
    previewStyle(drag?: boolean): void;
    private static getNewArrayLength;
    static ɵfac: i0.ɵɵFactoryDeclaration<GridsterComponent, never>;
    static ɵcmp: i0.ɵɵComponentDeclaration<GridsterComponent, "gridster", never, { "options": { "alias": "options"; "required": false; }; }, {}, never, ["*"], true, never>;
}
